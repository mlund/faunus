#define DIPOLEPARTICLE
#include <faunus/faunus.h>
#include <faunus/multipole.h>
#include <functional>
#include <iostream>
using namespace Faunus;                     
using namespace Faunus::Move;
using namespace Faunus::Potential;

typedef Space<Geometry::Cuboid,DipoleParticle> Tspace; 
typedef CoulombWolf TpairDDW;
typedef LennardJonesLB TpairLJ;

typedef CombinedPairPotential<TpairLJ,TpairDDW> Tpair;

template<class Tpairpot, class Tid>
bool savePotential(Tpairpot pot, Tid ida, Tid idb, string file) {
  std::ofstream f(file.c_str());
  if (f) {
    double min=1.1 * (atom[ida].radius+atom[idb].radius);
    DipoleParticle a,b;
    a=atom[ida];
    b=atom[idb];
    a.mu = Point(1,0,0);
    b.mu = Point(1,0,0);
    for (double r=0.1; r<=14; r+=0.05) {
      f << std::left << std::setw(10) << r << " "
        << pot(a,b,Point(r,0,0)) << endl;
    }
    return true;
  }
  return false;
}

int runSim(string name) {
  InputMap in(name);              
  
  cout << "IIQ Y" << endl;
  //Energy::NonbondedVector<Tspace,Tpair> pot(in);
  cout << "IIQ R" << endl;
  
  savePotential(IonIonQ(in), atom["sol"].id, atom["sol"].id, "pot_dipdip.dat");
  
  //std::cout << pot.info() << endl;
  
  return 0;
}

int main() {
  //cout << "Equilibration done ! Code: " << runSim("stockmayerEQ.input") << "!" << endl;
  int prod = runSim("water2.json");
  //cout << "Production done ! Code: " << prod << "!" << endl;
  return prod;
}